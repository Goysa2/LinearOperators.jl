{
    "docs": [
        {
            "location": "/", 
            "text": "A Julia Linear Operator Package\n\n\nOperators behave like matrices (with \nexceptions\n) but are defined by their effect when applied to a vector. They can be transposed, conjugated, or combined with other operators cheaply. The costly operation is deferred until multiplied with a vector.\n\n\n\n\nCompatibility\n\n\nJulia 0.4 and up.\n\n\n\n\nHow to Install\n\n\nPkg\n.\nadd\n(\nLinearOperators\n)\n\n\n\n\n\n\n\n\nOperators Available\n\n\n\n\n\n\n\n\nOperator\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nLinearOperator\n\n\nBase class. Useful to define operators from functions\n\n\n\n\n\n\nopEye\n\n\nIdentity operator\n\n\n\n\n\n\nopOnes\n\n\nAll ones operator\n\n\n\n\n\n\nopZeros\n\n\nAll zeros operator\n\n\n\n\n\n\nopDiagonal\n\n\nSquare (equivalent to \ndiagm()\n) or rectangular diagonal operator\n\n\n\n\n\n\nopInverse\n\n\nEquivalent to \n\\\n\n\n\n\n\n\nopCholesky\n\n\nMore efficient than \nopInverse\n for symmetric positive definite matrices\n\n\n\n\n\n\nopHouseholder\n\n\nApply a Householder transformation \nI-2hh'\n\n\n\n\n\n\nopHermitian\n\n\nRepresent a symmetric/hermitian operator based on the diagonal and strict lower triangle\n\n\n\n\n\n\nopRestriction\n\n\nRepresent a selection of \"rows\" when composed on the left with an existing operator\n\n\n\n\n\n\nopExtension\n\n\nRepresent a selection of \"columns\" when composed on the right with an existing operator\n\n\n\n\n\n\nLBFGSOperator\n\n\nLimited-memory BFGS approximation in operator form (damped or not)\n\n\n\n\n\n\nInverseLBFGSOperator\n\n\nInverse of a limited-memory BFGS approximation in operator form (damped or not)\n\n\n\n\n\n\nLSR1Operator\n\n\nLimited-memory SR1 approximation in operator form\n\n\n\n\n\n\n\n\n\n\nUtility Functions\n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncheck_ctranspose\n\n\nCheap check that \nA'\n is correctly implemented\n\n\n\n\n\n\ncheck_hermitian\n\n\nCheap check that \nA = A'\n\n\n\n\n\n\ncheck_positive_definite\n\n\nCheap check that an operator is positive (semi-)definite\n\n\n\n\n\n\ndiag\n\n\nExtract the diagonal of an operator\n\n\n\n\n\n\nfull\n\n\nConvert an abstract operator to a dense array\n\n\n\n\n\n\nhermitian\n\n\nDetermine whether the operator is Hermitian\n\n\n\n\n\n\npush!\n\n\nFor L-BFGS or L-SR1 operators, push a new pair \n\n\n\n\n\n\nreset!\n\n\nFor L-BFGS or L-SR1 operators, reset the data\n\n\n\n\n\n\nshape\n\n\nReturn the size of a linear operator\n\n\n\n\n\n\nshow\n\n\nDisplay basic information about an operator\n\n\n\n\n\n\nsize\n\n\nReturn the size of a linear operator\n\n\n\n\n\n\nsymmetric\n\n\nDetermine whether the operator is Symmetric\n\n\n\n\n\n\n\n\n\n\nOther Operations on Operators\n\n\nOperators can be transposed (\nA.'\n), conjugated (\nconj(A)\n) and conjugate-transposed (\nA'\n). Operators can be sliced (\nA[:,3], A[2:4,1:5], A[1,1]\n), but unlike matrices, they always return operators (see \ndifferences\n).\n\n\n\n\nDifferences\n\n\nUnlike matrices, an operator never \"becomes\" a vector or a number. We feel this increases compatibility among all operations, but may lead to errors if left unchecked.\n\n\nusing\n \nLinearOperators\n \n#hide\n\n\nA\n \n=\n \nrand\n(\n5\n,\n5\n)\n\n\nopA\n \n=\n \nLinearOperator\n(\nA\n)\n\n\nA\n[:,\n1\n]\n \n*\n \n3\n \n# Vector\n\n\n\n\n\n\n5-element Array{Float64,1}:\n 2.11413\n 0.420676\n 1.29065\n 2.51709\n 0.976359\n\n\n\n\n\nopA\n[:,\n1\n]\n \n*\n \n3\n \n# LinearOperator\n\n\n\n\n\n\nLinear operator\n  nrow: 5\n  ncol: 1\n  eltype: Float64\n  symmetric: false\n  hermitian: false\n  prod:   (anonymous function)\n  tprod:  Nullable((anonymous function))\n  ctprod: Nullable((anonymous function))\n\n\n\n\n\n# A[:,1] * [3] # ERROR\n\n\n\n\n\n\nopA\n[:,\n1\n]\n \n*\n \n[\n3\n]\n \n# Vector\n\n\n\n\n\n\n5-element Array{Float64,1}:\n 2.11413\n 0.420676\n 1.29065\n 2.51709\n 0.976359\n\n\n\n\n\nThis is also true for \nA[i,J]\n, which returns vectors on 0.5, and for the scalar \nA[i,j]\n. Below, \nopA[1,1]\n is an operator with the element \nA[1,1]\n.\n\n\n(\nopA\n[\n1\n,\n1\n]\n \n*\n \n[\n3\n])[\n1\n]\n \n-\n \nA\n[\n1\n,\n1\n]\n \n*\n \n3\n\n\n\n\n\n\n0.0\n\n\n\n\n\nIn the same spirit, the operator \nfull\n always returns a matrix.\n\n\nfull\n(\nopA\n[:,\n1\n])\n\n\n\n\n\n\n5x1 Array{Float64,2}:\n 0.704712\n 0.140225\n 0.430217\n 0.83903\n 0.325453\n\n\n\n\n\n\n\nOther Operators\n\n\n\n\nLLDL\n features a limited-memory   LDL\u1d40 factorization operator that may be used as preconditioner   in iterative methods\n\n\nMUMPS.jl\n features a full   distributed-memory factorization operator that may be used to represent the   preconditioner in, e.g., constraint-preconditioned Krylov methods.\n\n\n\n\n\n\nTesting\n\n\njulia\n \nPkg\n.\ntest\n(\nLinearOperators\n)", 
            "title": "Home"
        }, 
        {
            "location": "/#a-julia-linear-operator-package", 
            "text": "Operators behave like matrices (with  exceptions ) but are defined by their effect when applied to a vector. They can be transposed, conjugated, or combined with other operators cheaply. The costly operation is deferred until multiplied with a vector.", 
            "title": "A Julia Linear Operator Package"
        }, 
        {
            "location": "/#compatibility", 
            "text": "Julia 0.4 and up.", 
            "title": "Compatibility"
        }, 
        {
            "location": "/#how-to-install", 
            "text": "Pkg . add ( LinearOperators )", 
            "title": "How to Install"
        }, 
        {
            "location": "/#operators-available", 
            "text": "Operator  Description      LinearOperator  Base class. Useful to define operators from functions    opEye  Identity operator    opOnes  All ones operator    opZeros  All zeros operator    opDiagonal  Square (equivalent to  diagm() ) or rectangular diagonal operator    opInverse  Equivalent to  \\    opCholesky  More efficient than  opInverse  for symmetric positive definite matrices    opHouseholder  Apply a Householder transformation  I-2hh'    opHermitian  Represent a symmetric/hermitian operator based on the diagonal and strict lower triangle    opRestriction  Represent a selection of \"rows\" when composed on the left with an existing operator    opExtension  Represent a selection of \"columns\" when composed on the right with an existing operator    LBFGSOperator  Limited-memory BFGS approximation in operator form (damped or not)    InverseLBFGSOperator  Inverse of a limited-memory BFGS approximation in operator form (damped or not)    LSR1Operator  Limited-memory SR1 approximation in operator form", 
            "title": "Operators Available"
        }, 
        {
            "location": "/#utility-functions", 
            "text": "Function  Description      check_ctranspose  Cheap check that  A'  is correctly implemented    check_hermitian  Cheap check that  A = A'    check_positive_definite  Cheap check that an operator is positive (semi-)definite    diag  Extract the diagonal of an operator    full  Convert an abstract operator to a dense array    hermitian  Determine whether the operator is Hermitian    push!  For L-BFGS or L-SR1 operators, push a new pair     reset!  For L-BFGS or L-SR1 operators, reset the data    shape  Return the size of a linear operator    show  Display basic information about an operator    size  Return the size of a linear operator    symmetric  Determine whether the operator is Symmetric", 
            "title": "Utility Functions"
        }, 
        {
            "location": "/#other-operations-on-operators", 
            "text": "Operators can be transposed ( A.' ), conjugated ( conj(A) ) and conjugate-transposed ( A' ). Operators can be sliced ( A[:,3], A[2:4,1:5], A[1,1] ), but unlike matrices, they always return operators (see  differences ).", 
            "title": "Other Operations on Operators"
        }, 
        {
            "location": "/#differences", 
            "text": "Unlike matrices, an operator never \"becomes\" a vector or a number. We feel this increases compatibility among all operations, but may lead to errors if left unchecked.  using   LinearOperators   #hide  A   =   rand ( 5 , 5 )  opA   =   LinearOperator ( A )  A [:, 1 ]   *   3   # Vector   5-element Array{Float64,1}:\n 2.11413\n 0.420676\n 1.29065\n 2.51709\n 0.976359  opA [:, 1 ]   *   3   # LinearOperator   Linear operator\n  nrow: 5\n  ncol: 1\n  eltype: Float64\n  symmetric: false\n  hermitian: false\n  prod:   (anonymous function)\n  tprod:  Nullable((anonymous function))\n  ctprod: Nullable((anonymous function))  # A[:,1] * [3] # ERROR   opA [:, 1 ]   *   [ 3 ]   # Vector   5-element Array{Float64,1}:\n 2.11413\n 0.420676\n 1.29065\n 2.51709\n 0.976359  This is also true for  A[i,J] , which returns vectors on 0.5, and for the scalar  A[i,j] . Below,  opA[1,1]  is an operator with the element  A[1,1] .  ( opA [ 1 , 1 ]   *   [ 3 ])[ 1 ]   -   A [ 1 , 1 ]   *   3   0.0  In the same spirit, the operator  full  always returns a matrix.  full ( opA [:, 1 ])   5x1 Array{Float64,2}:\n 0.704712\n 0.140225\n 0.430217\n 0.83903\n 0.325453", 
            "title": "Differences"
        }, 
        {
            "location": "/#other-operators", 
            "text": "LLDL  features a limited-memory   LDL\u1d40 factorization operator that may be used as preconditioner   in iterative methods  MUMPS.jl  features a full   distributed-memory factorization operator that may be used to represent the   preconditioner in, e.g., constraint-preconditioned Krylov methods.", 
            "title": "Other Operators"
        }, 
        {
            "location": "/#testing", 
            "text": "julia   Pkg . test ( LinearOperators )", 
            "title": "Testing"
        }, 
        {
            "location": "/tutorial/", 
            "text": "Using matrices\n\n\nOperators may be defined from matrices and combined using the usual operations, but the result is deferred until the operator is applied.\n\n\nusing\n \nLinearOperators\n\n\nA1\n \n=\n \nrand\n(\n5\n,\n7\n)\n\n\nA2\n \n=\n \nsprand\n(\n7\n,\n3\n,\n.\n3\n)\n\n\nop1\n \n=\n \nLinearOperator\n(\nA1\n)\n\n\nop2\n \n=\n \nLinearOperator\n(\nA2\n)\n\n\nop\n \n=\n \nop1\n \n*\n \nop2\n  \n# Does not form A1 * A2\n\n\nx\n \n=\n \nrand\n(\n3\n)\n\n\ny\n \n=\n \nop\n \n*\n \nx\n\n\n\n\n\n\n5-element Array{Float64,1}:\n 0.588273\n 0.608285\n 0.687189\n 0.450403\n 0.170181\n\n\n\n\n\n\n\nInverse\n\n\nOperators may be defined to represent (approximate) inverses.\n\n\nA\n \n=\n \nrand\n(\n5\n,\n5\n)\n\n\nA\n \n=\n \nA\n \n*\n \nA\n\n\nop\n \n=\n \nopCholesky\n(\nA\n)\n  \n# Use, e.g., as a preconditioner\n\n\nv\n \n=\n \nrand\n(\n5\n)\n\n\nnorm\n(\nA\n \\ \nv\n \n-\n \nop\n \n*\n \nv\n)\n \n/\n \nnorm\n(\nv\n)\n\n\n\n\n\n\n1.41197810218191e-13\n\n\n\n\n\nIn this example, the Cholesky factor is computed only once and can be used many times transparently.\n\n\n\n\nUsing functions\n\n\nOperators may be defined from functions. In the example below, the transposed isn't defined, but it may be inferred from the conjugate transposed. Missing operations are represented as \nnullable\n functions. Nullable types were introduced in Julia 0.4.\n\n\ndft\n \n=\n \nLinearOperator\n(\n10\n,\n \n10\n,\n \nfalse\n,\n \nfalse\n,\n\n                     \nv\n \n-\n \nfft\n(\nv\n),\n\n                     \nNullable\n{\nFunction\n}(),\n  \n# will be inferred\n\n                     \nw\n \n-\n \nifft\n(\nw\n))\n\n\nx\n \n=\n \nrand\n(\n10\n)\n\n\ny\n \n=\n \ndft\n \n*\n \nx\n\n\nnorm\n(\ndft\n \n*\n \ny\n \n-\n \nx\n)\n  \n# DFT is an orthogonal operator\n\n\n\n\n\n\n1.7554167342883506e-16\n\n\n\n\n\ndft\n.\n \n*\n \ny\n\n\n\n\n\n\n10-element Array{Complex{Float64},1}:\n  0.351429-0.0im\n  0.460654-0.0im\n  0.920645+0.0im\n  0.696891-0.0im\n   0.50868-0.0im\n  0.299021-0.0im\n  0.822928-0.0im\n  0.672046-0.0im\n  0.840862-0.0im\n 0.0616156-0.0im\n\n\n\n\n\nBy default a linear operator defined by functions and that is neither symmetric nor hermitian will have element type \nComplex128\n. This behavior may be overridden by specifying the type explicitly, e.g.,\n\n\ndft\n \n=\n \nLinearOperator\n{\nFloat64\n}(\n10\n,\n \n10\n,\n \nfalse\n,\n \nfalse\n,\n\n                              \nv\n \n-\n \nfft\n(\nv\n),\n\n                              \nNullable\n{\nFunction\n}(),\n\n                              \nw\n \n-\n \nifft\n(\nw\n))\n\n\n\n\n\n\n\n\nLimited memory BFGS\n\n\nTwo other useful operators are the Limited-Memory BFGS in forward and inverse form.\n\n\nB\n \n=\n \nLBFGSOperator\n(\n20\n)\n\n\nH\n \n=\n \nInverseLBFGSOperator\n(\n20\n)\n\n\nr\n \n=\n \n0.0\n\n\nfor\n \ni\n \n=\n \n1\n:\n100\n\n  \ns\n \n=\n \nrand\n(\n20\n)\n\n  \ny\n \n=\n \nrand\n(\n20\n)\n\n  \npush!\n(\nB\n,\n \ns\n,\n \ny\n)\n\n  \npush!\n(\nH\n,\n \ns\n,\n \ny\n)\n\n  \nr\n \n+=\n \nnorm\n(\nB\n \n*\n \nH\n \n*\n \ns\n \n-\n \ns\n)\n\n\nend\n\n\nr\n\n\n\n\n\n\n4.268937495574098e-13\n\n\n\n\n\nThere is also a LSR1 operator that behaves similarly to these ones.\n\n\n\n\nRestriction, extension and slices\n\n\nThe restriction operator restricts a vector to a set of indices.\n\n\nv\n \n=\n \ncollect\n(\n1\n:\n5\n)\n\n\nR\n \n=\n \nopRestriction\n([\n2\n;\n5\n],\n \n5\n)\n\n\nR\n \n*\n \nv\n\n\n\n\n\n\n2-element Array{Int64,1}:\n 2\n 5\n\n\n\n\n\nNotice that it corresponds to a matrix with lines of the identity given by the indices.\n\n\nfull\n(\nR\n)\n\n\n\n\n\n\n2x5 Array{Int64,2}:\n 0  1  0  0  0\n 0  0  0  0  1\n\n\n\n\n\nThe extension operator is the transpose of the restriction. It extends a vector with zeros.\n\n\nv\n \n=\n \ncollect\n(\n1\n:\n2\n)\n\n\nE\n \n=\n \nopExtension\n([\n2\n;\n5\n],\n \n5\n)\n\n\nE\n \n*\n \nv\n\n\n\n\n\n\n5-element Array{Int64,1}:\n 0\n 1\n 0\n 0\n 2\n\n\n\n\n\nWith these operators, we define the slices of an operator \nop\n.\n\n\nA\n \n=\n \nrand\n(\n5\n,\n5\n)\n\n\nopA\n \n=\n \nLinearOperator\n(\nA\n)\n\n\nI\n \n=\n \n[\n1\n;\n3\n;\n5\n]\n\n\nJ\n \n=\n \n2\n:\n4\n\n\nA\n[\nI\n,\nJ\n]\n \n*\n \nones\n(\n3\n)\n\n\n\n\n\n\n3-element Array{Float64,1}:\n 1.28511\n 1.90627\n 1.60116\n\n\n\n\n\nopRestriction\n(\nI\n,\n \n5\n)\n \n*\n \nopA\n \n*\n \nopExtension\n(\nJ\n,\n \n5\n)\n \n*\n \nones\n(\n3\n)\n\n\n\n\n\n\n3-element Array{Float64,1}:\n 1.28511\n 1.90627\n 1.60116\n\n\n\n\n\nA main \ndifference\n with matrices, is that slices \ndo not\n return vectors nor numbers.\n\n\nopA\n[\n1\n,:]\n \n*\n \nones\n(\n5\n)\n\n\n\n\n\n\n1-element Array{Float64,1}:\n 2.64138\n\n\n\n\n\nopA\n[:,\n1\n]\n \n*\n \nones\n(\n1\n)\n\n\n\n\n\n\n5-element Array{Float64,1}:\n 0.905658\n 0.316604\n 0.75611\n 0.836598\n 0.671597\n\n\n\n\n\nopA\n[\n1\n,\n1\n]\n \n*\n \nones\n(\n1\n)\n\n\n\n\n\n\n1-element Array{Float64,1}:\n 0.905658", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#using-matrices", 
            "text": "Operators may be defined from matrices and combined using the usual operations, but the result is deferred until the operator is applied.  using   LinearOperators  A1   =   rand ( 5 , 7 )  A2   =   sprand ( 7 , 3 , . 3 )  op1   =   LinearOperator ( A1 )  op2   =   LinearOperator ( A2 )  op   =   op1   *   op2    # Does not form A1 * A2  x   =   rand ( 3 )  y   =   op   *   x   5-element Array{Float64,1}:\n 0.588273\n 0.608285\n 0.687189\n 0.450403\n 0.170181", 
            "title": "Using matrices"
        }, 
        {
            "location": "/tutorial/#inverse", 
            "text": "Operators may be defined to represent (approximate) inverses.  A   =   rand ( 5 , 5 )  A   =   A   *   A  op   =   opCholesky ( A )    # Use, e.g., as a preconditioner  v   =   rand ( 5 )  norm ( A  \\  v   -   op   *   v )   /   norm ( v )   1.41197810218191e-13  In this example, the Cholesky factor is computed only once and can be used many times transparently.", 
            "title": "Inverse"
        }, 
        {
            "location": "/tutorial/#using-functions", 
            "text": "Operators may be defined from functions. In the example below, the transposed isn't defined, but it may be inferred from the conjugate transposed. Missing operations are represented as  nullable  functions. Nullable types were introduced in Julia 0.4.  dft   =   LinearOperator ( 10 ,   10 ,   false ,   false , \n                      v   -   fft ( v ), \n                      Nullable { Function }(),    # will be inferred \n                      w   -   ifft ( w ))  x   =   rand ( 10 )  y   =   dft   *   x  norm ( dft   *   y   -   x )    # DFT is an orthogonal operator   1.7554167342883506e-16  dft .   *   y   10-element Array{Complex{Float64},1}:\n  0.351429-0.0im\n  0.460654-0.0im\n  0.920645+0.0im\n  0.696891-0.0im\n   0.50868-0.0im\n  0.299021-0.0im\n  0.822928-0.0im\n  0.672046-0.0im\n  0.840862-0.0im\n 0.0616156-0.0im  By default a linear operator defined by functions and that is neither symmetric nor hermitian will have element type  Complex128 . This behavior may be overridden by specifying the type explicitly, e.g.,  dft   =   LinearOperator { Float64 }( 10 ,   10 ,   false ,   false , \n                               v   -   fft ( v ), \n                               Nullable { Function }(), \n                               w   -   ifft ( w ))", 
            "title": "Using functions"
        }, 
        {
            "location": "/tutorial/#limited-memory-bfgs", 
            "text": "Two other useful operators are the Limited-Memory BFGS in forward and inverse form.  B   =   LBFGSOperator ( 20 )  H   =   InverseLBFGSOperator ( 20 )  r   =   0.0  for   i   =   1 : 100 \n   s   =   rand ( 20 ) \n   y   =   rand ( 20 ) \n   push! ( B ,   s ,   y ) \n   push! ( H ,   s ,   y ) \n   r   +=   norm ( B   *   H   *   s   -   s )  end  r   4.268937495574098e-13  There is also a LSR1 operator that behaves similarly to these ones.", 
            "title": "Limited memory BFGS"
        }, 
        {
            "location": "/tutorial/#restriction-extension-and-slices", 
            "text": "The restriction operator restricts a vector to a set of indices.  v   =   collect ( 1 : 5 )  R   =   opRestriction ([ 2 ; 5 ],   5 )  R   *   v   2-element Array{Int64,1}:\n 2\n 5  Notice that it corresponds to a matrix with lines of the identity given by the indices.  full ( R )   2x5 Array{Int64,2}:\n 0  1  0  0  0\n 0  0  0  0  1  The extension operator is the transpose of the restriction. It extends a vector with zeros.  v   =   collect ( 1 : 2 )  E   =   opExtension ([ 2 ; 5 ],   5 )  E   *   v   5-element Array{Int64,1}:\n 0\n 1\n 0\n 0\n 2  With these operators, we define the slices of an operator  op .  A   =   rand ( 5 , 5 )  opA   =   LinearOperator ( A )  I   =   [ 1 ; 3 ; 5 ]  J   =   2 : 4  A [ I , J ]   *   ones ( 3 )   3-element Array{Float64,1}:\n 1.28511\n 1.90627\n 1.60116  opRestriction ( I ,   5 )   *   opA   *   opExtension ( J ,   5 )   *   ones ( 3 )   3-element Array{Float64,1}:\n 1.28511\n 1.90627\n 1.60116  A main  difference  with matrices, is that slices  do not  return vectors nor numbers.  opA [ 1 ,:]   *   ones ( 5 )   1-element Array{Float64,1}:\n 2.64138  opA [:, 1 ]   *   ones ( 1 )   5-element Array{Float64,1}:\n 0.905658\n 0.316604\n 0.75611\n 0.836598\n 0.671597  opA [ 1 , 1 ]   *   ones ( 1 )   1-element Array{Float64,1}:\n 0.905658", 
            "title": "Restriction, extension and slices"
        }, 
        {
            "location": "/reference/", 
            "text": "Operators\n\n\n#\n\n\nLinearOperators.LinearOperator\n \n \nType\n.\n\n\nBase type to represent a linear operator. The usual arithmetic operations may be applied to operators to combine or otherwise alter them. They can be combined with other operators, with matrices and with scalars. Operators may be transposed and conjugate-transposed using the usual Julia syntax.\n\n\nLinearOperator(M; symmetric=false, hermitian=false)\n\n\n\n\n\nConstruct a linear operator from a dense or sparse matrix. Use the optional keyword arguments to indicate whether the operator is symmetric and/or hermitian.\n\n\nLinearOperator(M)\n\n\n\n\n\nConstructs a linear operator from a symmetric tridiagonal matrix. If its elements are real, it is also Hermitian, otherwise complex symmetric.\n\n\nLinearOperator(M)\n\n\n\n\n\nConstructs a linear operator from a symmetric matrix. If its elements are real, it is also Hermitian, otherwise complex symmetric.\n\n\nLinearOperator(M)\n\n\n\n\n\nConstructs a linear operator from a Hermitian matrix. If its elements are real, it is also symmetric.\n\n\nLinearOperator(nrow, ncol, symmetric, hermitian, prod,\n                [tprod=Nullable(), ctprod=Nullable()])\n\n\n\n\n\nConstruct a linear operator from functions.\n\n\n#\n\n\nLinearOperators.opEye\n \n \nFunction\n.\n\n\nopEye(T, n)\nopEye(n)\n\n\n\n\n\nIdentity operator of order \nn\n and of data type \nT\n (defaults to \nFloat64\n).\n\n\nopEye(T, nrow, ncol)\nopEye(nrow, ncol)\n\n\n\n\n\nRectangular identity operator of size \nnrow\nx\nncol\n and of data type \nT\n (defaults to \nFloat64\n).\n\n\n#\n\n\nLinearOperators.opOnes\n \n \nFunction\n.\n\n\nopOnes(T, nrow, ncol)\nopOnes(nrow, ncol)\n\n\n\n\n\nOperator of all ones of size \nnrow\n-by-\nncol\n and of data type \nT\n (defaults to \nFloat64\n).\n\n\n#\n\n\nLinearOperators.opZeros\n \n \nFunction\n.\n\n\nopZeros(T, nrow, ncol)\nopZeros(nrow, ncol)\n\n\n\n\n\nZero operator of size \nnrow\n-by-\nncol\n and of data type \nT\n (defaults to \nFloat64\n).\n\n\n#\n\n\nLinearOperators.opDiagonal\n \n \nFunction\n.\n\n\nopDiagonal(d)\n\n\n\n\n\nDiagonal operator with the vector \nd\n on its main diagonal.\n\n\nopDiagonal(nrow, ncol, d)\n\n\n\n\n\nRectangular diagonal operator of size \nnrow\n-by-\nncol\n with the vector \nd\n on its main diagonal.\n\n\n#\n\n\nLinearOperators.opInverse\n \n \nFunction\n.\n\n\nopInverse(M; symmetric=false, hermitian=false)\n\n\n\n\n\nInverse of a matrix as a linear operator using \n\\\n. Useful for triangular matrices. Note that each application of this operator applies \n\\\n.\n\n\n#\n\n\nLinearOperators.opCholesky\n \n \nFunction\n.\n\n\nopCholesky(M, [check=false])\n\n\n\n\n\nInverse of a positive definite matrix as a linear operator using its Cholesky factorization. The factorization is computed only once. The optional \ncheck\n argument will perform cheap hermicity and definiteness checks.\n\n\n#\n\n\nLinearOperators.opHouseholder\n \n \nFunction\n.\n\n\nopHouseholder(h)\n\n\n\n\n\nApply a Householder transformation defined by the vector \nh\n. The result is \nx -\n (I - 2 h h') x\n.\n\n\n#\n\n\nLinearOperators.opHermitian\n \n \nFunction\n.\n\n\nopHermitian(d, A)\n\n\n\n\n\nA symmetric/hermitian operator based on the diagonal \nd\n and lower triangle of \nA\n.\n\n\nopHermitian(A)\n\n\n\n\n\nA symmetric/hermitian operator based on a matrix.\n\n\n#\n\n\nLinearOperators.opRestriction\n \n \nFunction\n.\n\n\nZ = opRestriction(I, ncol)\nZ = opRestriction(:, ncol)\n\n\n\n\n\nCreates a LinearOperator restricting a \nncol\n-sized vector to indices \nI\n. The operation \nZ * v\n is equivalent to \nv[I]\n. \nI\n can be \n:\n.\n\n\nZ = opRestriction(k, ncol)\n\n\n\n\n\nAlias for \nopRestriction([k], ncol)\n.\n\n\n#\n\n\nLinearOperators.opExtension\n \n \nFunction\n.\n\n\nZ = opExtension(I, ncol)\nZ = opExtension(:, ncol)\n\n\n\n\n\nCreates a LinearOperator extending a vector of size \nlength(I)\n to size \nncol\n, where the position of the elements on the new vector are given by the indices \nI\n. The operation \nw = Z * v\n is equivalent to \nw = zeros(ncol); w[I] = v\n.\n\n\nZ = opExtension(k, ncol)\n\n\n\n\n\nAlias for \nopExtension([k], ncol)\n.\n\n\n#\n\n\nLinearOperators.LBFGSOperator\n \n \nType\n.\n\n\nA type for limited-memory BFGS approximations.\n\n\n#\n\n\nLinearOperators.InverseLBFGSOperator\n \n \nFunction\n.\n\n\nInverseLBFGSOperator(T, n, [mem=5; scaling=false])\nInverseLBFGSOperator(n, [mem=5; scaling=false])\n\n\n\n\n\nConstruct a limited-memory BFGS approximation in inverse form. If the type \nT\n is omitted, then \nFloat64\n is used.\n\n\n#\n\n\nLinearOperators.LSR1Operator\n \n \nType\n.\n\n\nA type for limited-memory SR1 approximations.\n\n\n\n\nUtility functions\n\n\n#\n\n\nLinearOperators.check_ctranspose\n \n \nFunction\n.\n\n\ncheck_ctranspose(op)\n\n\n\n\n\nCheap check that the operator and its conjugate transposed are related.\n\n\n#\n\n\nLinearOperators.check_hermitian\n \n \nFunction\n.\n\n\ncheck_hermitian(op)\n\n\n\n\n\nCheap check that the operator is Hermitian.\n\n\n#\n\n\nLinearOperators.check_positive_definite\n \n \nFunction\n.\n\n\ncheck_positive_definite(op; semi=false)\n\n\n\n\n\nCheap check that the operator is positive (semi-)definite.\n\n\n#\n\n\nBase.LinAlg.diag\n \n \nFunction\n.\n\n\ndiag(op)\n\n\n\n\n\nExtract the diagonal of a L-BFGS operator in forward mode.\n\n\ndiag(op)\n\n\n\n\n\nExtract the diagonal of a L-SR1 operator in forward mode.\n\n\n#\n\n\nBase.full\n \n \nFunction\n.\n\n\nA = full(op)\n\n\n\n\n\nMaterialize an operator as a dense array using \nop.ncol\n products.\n\n\n#\n\n\nLinearOperators.hermitian\n \n \nFunction\n.\n\n\nhermitian(op)\nishermitian(op)\n\n\n\n\n\nDetermine whether the operator is Hermitian.\n\n\n#\n\n\nBase.push!\n \n \nFunction\n.\n\n\npush!(op, s, y)\n\n\n\n\n\nPush a new {s,y} pair into a L-BFGS operator.\n\n\npush!(op, s, y)\n\n\n\n\n\nPush a new {s,y} pair into a L-SR1 operator.\n\n\n#\n\n\nLinearOperators.reset!\n \n \nFunction\n.\n\n\nreset!(data)\n\n\n\n\n\nResets the given LBFGS data.\n\n\nreset!(op)\n\n\n\n\n\nResets the LBFGS data of the given operator.\n\n\nreset!(data)\n\n\n\n\n\nReset the given LSR1 data.\n\n\nreset!(op)\n\n\n\n\n\nResets the LSR1 data of the given operator.\n\n\n#\n\n\nLinearOperators.shape\n \n \nFunction\n.\n\n\nm, n = shape(op)\n\n\n\n\n\nAn alias for size.\n\n\n#\n\n\nBase.show\n \n \nFunction\n.\n\n\nshow(io, op)\n\n\n\n\n\nDisplay basic information about a linear operator.\n\n\n#\n\n\nBase.size\n \n \nFunction\n.\n\n\nm, n = size(op)\n\n\n\n\n\nReturn the size of a linear operator as a tuple.\n\n\nm = size(op, d)\n\n\n\n\n\nReturn the size of a linear operator along dimension \nd\n.\n\n\n#\n\n\nLinearOperators.symmetric\n \n \nFunction\n.\n\n\nsymmetric(op)\nissymmetric(op)\n\n\n\n\n\nDetermine whether the operator is symmetric.", 
            "title": "Reference"
        }, 
        {
            "location": "/reference/#operators", 
            "text": "#  LinearOperators.LinearOperator     Type .  Base type to represent a linear operator. The usual arithmetic operations may be applied to operators to combine or otherwise alter them. They can be combined with other operators, with matrices and with scalars. Operators may be transposed and conjugate-transposed using the usual Julia syntax.  LinearOperator(M; symmetric=false, hermitian=false)  Construct a linear operator from a dense or sparse matrix. Use the optional keyword arguments to indicate whether the operator is symmetric and/or hermitian.  LinearOperator(M)  Constructs a linear operator from a symmetric tridiagonal matrix. If its elements are real, it is also Hermitian, otherwise complex symmetric.  LinearOperator(M)  Constructs a linear operator from a symmetric matrix. If its elements are real, it is also Hermitian, otherwise complex symmetric.  LinearOperator(M)  Constructs a linear operator from a Hermitian matrix. If its elements are real, it is also symmetric.  LinearOperator(nrow, ncol, symmetric, hermitian, prod,\n                [tprod=Nullable(), ctprod=Nullable()])  Construct a linear operator from functions.  #  LinearOperators.opEye     Function .  opEye(T, n)\nopEye(n)  Identity operator of order  n  and of data type  T  (defaults to  Float64 ).  opEye(T, nrow, ncol)\nopEye(nrow, ncol)  Rectangular identity operator of size  nrow x ncol  and of data type  T  (defaults to  Float64 ).  #  LinearOperators.opOnes     Function .  opOnes(T, nrow, ncol)\nopOnes(nrow, ncol)  Operator of all ones of size  nrow -by- ncol  and of data type  T  (defaults to  Float64 ).  #  LinearOperators.opZeros     Function .  opZeros(T, nrow, ncol)\nopZeros(nrow, ncol)  Zero operator of size  nrow -by- ncol  and of data type  T  (defaults to  Float64 ).  #  LinearOperators.opDiagonal     Function .  opDiagonal(d)  Diagonal operator with the vector  d  on its main diagonal.  opDiagonal(nrow, ncol, d)  Rectangular diagonal operator of size  nrow -by- ncol  with the vector  d  on its main diagonal.  #  LinearOperators.opInverse     Function .  opInverse(M; symmetric=false, hermitian=false)  Inverse of a matrix as a linear operator using  \\ . Useful for triangular matrices. Note that each application of this operator applies  \\ .  #  LinearOperators.opCholesky     Function .  opCholesky(M, [check=false])  Inverse of a positive definite matrix as a linear operator using its Cholesky factorization. The factorization is computed only once. The optional  check  argument will perform cheap hermicity and definiteness checks.  #  LinearOperators.opHouseholder     Function .  opHouseholder(h)  Apply a Householder transformation defined by the vector  h . The result is  x -  (I - 2 h h') x .  #  LinearOperators.opHermitian     Function .  opHermitian(d, A)  A symmetric/hermitian operator based on the diagonal  d  and lower triangle of  A .  opHermitian(A)  A symmetric/hermitian operator based on a matrix.  #  LinearOperators.opRestriction     Function .  Z = opRestriction(I, ncol)\nZ = opRestriction(:, ncol)  Creates a LinearOperator restricting a  ncol -sized vector to indices  I . The operation  Z * v  is equivalent to  v[I] .  I  can be  : .  Z = opRestriction(k, ncol)  Alias for  opRestriction([k], ncol) .  #  LinearOperators.opExtension     Function .  Z = opExtension(I, ncol)\nZ = opExtension(:, ncol)  Creates a LinearOperator extending a vector of size  length(I)  to size  ncol , where the position of the elements on the new vector are given by the indices  I . The operation  w = Z * v  is equivalent to  w = zeros(ncol); w[I] = v .  Z = opExtension(k, ncol)  Alias for  opExtension([k], ncol) .  #  LinearOperators.LBFGSOperator     Type .  A type for limited-memory BFGS approximations.  #  LinearOperators.InverseLBFGSOperator     Function .  InverseLBFGSOperator(T, n, [mem=5; scaling=false])\nInverseLBFGSOperator(n, [mem=5; scaling=false])  Construct a limited-memory BFGS approximation in inverse form. If the type  T  is omitted, then  Float64  is used.  #  LinearOperators.LSR1Operator     Type .  A type for limited-memory SR1 approximations.", 
            "title": "Operators"
        }, 
        {
            "location": "/reference/#utility-functions", 
            "text": "#  LinearOperators.check_ctranspose     Function .  check_ctranspose(op)  Cheap check that the operator and its conjugate transposed are related.  #  LinearOperators.check_hermitian     Function .  check_hermitian(op)  Cheap check that the operator is Hermitian.  #  LinearOperators.check_positive_definite     Function .  check_positive_definite(op; semi=false)  Cheap check that the operator is positive (semi-)definite.  #  Base.LinAlg.diag     Function .  diag(op)  Extract the diagonal of a L-BFGS operator in forward mode.  diag(op)  Extract the diagonal of a L-SR1 operator in forward mode.  #  Base.full     Function .  A = full(op)  Materialize an operator as a dense array using  op.ncol  products.  #  LinearOperators.hermitian     Function .  hermitian(op)\nishermitian(op)  Determine whether the operator is Hermitian.  #  Base.push!     Function .  push!(op, s, y)  Push a new {s,y} pair into a L-BFGS operator.  push!(op, s, y)  Push a new {s,y} pair into a L-SR1 operator.  #  LinearOperators.reset!     Function .  reset!(data)  Resets the given LBFGS data.  reset!(op)  Resets the LBFGS data of the given operator.  reset!(data)  Reset the given LSR1 data.  reset!(op)  Resets the LSR1 data of the given operator.  #  LinearOperators.shape     Function .  m, n = shape(op)  An alias for size.  #  Base.show     Function .  show(io, op)  Display basic information about a linear operator.  #  Base.size     Function .  m, n = size(op)  Return the size of a linear operator as a tuple.  m = size(op, d)  Return the size of a linear operator along dimension  d .  #  LinearOperators.symmetric     Function .  symmetric(op)\nissymmetric(op)  Determine whether the operator is symmetric.", 
            "title": "Utility functions"
        }
    ]
}